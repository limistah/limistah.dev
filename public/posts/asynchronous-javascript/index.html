<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Asynchronous Javascript | limistah</title>
<meta name=keywords content="JS"><meta name=description content="In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing, and likes, stand as a forbearer for the actual task that happens in a system.
While all of the above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.
In his Concurrency glossary, slikts (dabas@untu.ms) wrote about asynchronous, he said:
Asynchrony means &ldquo;not happening at the same time&rdquo;, and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn&rsquo;t blocked until the receiver is ready."><meta name=author content="AI"><link rel=canonical href=https://limistah.dev/posts/asynchronous-javascript/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://limistah.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://limistah.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://limistah.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://limistah.dev/apple-touch-icon.png><link rel=mask-icon href=https://limistah.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Asynchronous Javascript"><meta property="og:description" content="In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing, and likes, stand as a forbearer for the actual task that happens in a system.
While all of the above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.
In his Concurrency glossary, slikts (dabas@untu.ms) wrote about asynchronous, he said:
Asynchrony means &ldquo;not happening at the same time&rdquo;, and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn&rsquo;t blocked until the receiver is ready."><meta property="og:type" content="article"><meta property="og:url" content="https://limistah.dev/posts/asynchronous-javascript/"><meta property="og:image" content="https://limistah.dev/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-03T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://limistah.dev/images/papermod-cover.png"><meta name=twitter:title content="Asynchronous Javascript"><meta name=twitter:description content="In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing, and likes, stand as a forbearer for the actual task that happens in a system.
While all of the above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.
In his Concurrency glossary, slikts (dabas@untu.ms) wrote about asynchronous, he said:
Asynchrony means &ldquo;not happening at the same time&rdquo;, and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn&rsquo;t blocked until the receiver is ready."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://limistah.dev/posts/"},{"@type":"ListItem","position":2,"name":"Asynchronous Javascript","item":"https://limistah.dev/posts/asynchronous-javascript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Asynchronous Javascript","name":"Asynchronous Javascript","description":"In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing, and likes, stand as a forbearer for the actual task that happens in a system.\nWhile all of the above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.\nIn his Concurrency glossary, slikts (dabas@untu.ms) wrote about asynchronous, he said:\nAsynchrony means \u0026ldquo;not happening at the same time\u0026rdquo;, and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn\u0026rsquo;t blocked until the receiver is ready.","keywords":["JS"],"articleBody":"In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing, and likes, stand as a forbearer for the actual task that happens in a system.\nWhile all of the above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.\nIn his Concurrency glossary, slikts (dabas@untu.ms) wrote about asynchronous, he said:\nAsynchrony means “not happening at the same time”, and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn’t blocked until the receiver is ready.\nIt might not be clear; still, we will go into a later detail about this with a real-life example. Don’t tell anyone, life is mostly asynchronous.\nWhile languages like Java, C#, C++, etc. run their computation on their main thread and could spawn out a new thread to run another set of instructions which are in parallel to the main thread and could also communicate with it. JavaScript, in its uniqueness, does not support that model of computation.\nIn JavaScript, all computations and instructions run in a sequence (i.e., one after another) in a single thread. This means that for instructions ranging from A, B, C, D, E to be executed, A would be executed first and when done, B is then executed, then C, then D, then E, which sees the program to its end.\nStill, with the single-threaded nature of JavaScript, there is a unique feature that makes it outstanding, it is its non-blocking I/O model.\nI/O(Input/Output) could be in any form, like fetching of data over the internet, getting a file from the filesystem and likes, all of these processes does not block the main thread from continuing its execution.\nA real life case study In high school, when students are given an assignment, they are required to submit it. Once they submit the task to the teacher, they are expected to wait until their books are returned back to them already marked/graded.\nWhile they had submitted the assignments and are waiting for the results, they could do other things like reading, attend classes, play games, and joke with friends.\nOnce the teacher is done marking, the students are notified, then they would go to the teacher to pick them up, completing the process.\nIn this scenario, the students have done a task asynchronously. While the teacher could only do one thing at a time, they have asked the teacher to teach them and still mark their assignments.\nThe teacher could not complete both of them at the same time, so they would have to wait, but, set a trigger (through the class rep/governor) that made them know that the assignments are ready and the results are out.\nThe notification could help the students to determine what next to do. Maybe, to proceed with putting their books into their bags or doing the corrections or learning from other classmates. (whatever is next)\nThat is what happens in asynchronous programming.\nAsynchrony in JavaScript JavaScript as a language comes with support for asynchronous programming; there have been different ways to come up with this. Most common is the callbacks, which could be seen in many legacy code bases.\nIn the modern JavaScript engine, there is an added support for writing asynchronous code. We would be exploring these options and their demerits, and I would conclude with why I think that Async/Await as a feature of the language is too essential to understand. Let’s hit the start knob.\nCallbacks For seasoned developers, this might seem like unveiling a nightmare following their experiences with callback hell. But, a callback is not that bad.\nA callback is a function passed during a function call/invocation to be executed when the called function determines. A basic example is what setTimeout, setInterval do. Once any of them get called, it takes the function and executes it at the specified time passed from their second argument.\nsetTimeout(() =\u003e console.log(\"This is a callback 1 sec. setTimeout test\"), 1000) setInterval( () =\u003e console.log(\"This is a callback 1 sec. setInterval test\"), 1000 ) The two function calls above receive a callback as their first argument and execute it once they each reach the time (1sec) in their second argument. They will never obstruct the main thread from continuing executing other functions; instead, an entry is made in the call stack to take care of this.\nAnother great example is in the DOM Events API. A basic onclick event could be listened to like this:\nconst button = document.getElementById(\"#submitButton\") button.addEventListener(\"click\", () =\u003e { console.log(\"Submit Button Clicked\") }) Once the button is clicked, with the single thread nature of JavaScript, one would expect that the above code should work like this:\nStore the DOM reference of submitButton to the button variable. button.addEventListener is called which puts in an entry into the call stack The event is registered against a click name, and the code for the addEventListener is executed. Once it is executed, the function/handler should be triggered immediately in the addEventListener execution context As stated in the above, we expect all of those to happen in parallel. But, what happens there is that code and functions are delegated to a later time when an actual action has happened. Recall the High School Assignment illustration we gave?\nWhat happens is that:\nOnce the click event has been triggered on the button, the function would be executed. And this could happen any time in the future, but other code could still run while waiting for this.\nGood Ol’days of AJAX With the myriads of NPM libraries that make this happen in a few lines of JS code. Also, the inclusion of the fetch API to the modern JavaScript engines has made this to be so uncommon to the modern developers what AJAX means right in the browser, as they take away the underlying fact about AJAX web requests.\nBefore the days of EcmaScript 6, while developers still really disliked working with JavaScript (which is unavoidable for web developers, though 😄), web requests could be made over the internet through an XMLHTTPRequest object. The technique for making this request was later formed to be called Asynchronous JavaScript and XML, popularly known as AJAX.\nWhat AJAX means is that we could request the internet, wait for the result to come while still having other things going on in the browser (basically, a loading icon). This is asynchronous in nature, and the main reason why it is called AJAX.\nAJAX uses the callback model, a basic vanilla AJAX request using the XMLHTTPRequest object looks like this:\n// Picked from https://www.w3schools.com/xml/xml_http.asp var xhttp = new XMLHttpRequest() xhttp.onreadystatechange = function () { if (this.readyState == 4 \u0026\u0026 this.status == 200) { // Typical action to be performed when the document is ready: document.getElementById(\"demo\").innerHTML = xhttp.responseText } } xhttp.open(\"GET\", \"filename\", true) xhttp.send() It is not attractive, I know. If you are a modern JavaScript developer, respect those that have passed through this and still look uncool to you, this was so cool to them back then.\nThis AJAX feature utilized the model of event handling and was very easy to comprehend by JavaScript developers. But, it shares a similar problem with all callback-based coding patterns/techniques.\nCallback Hell Does it mean hell in our code/machines, well, not necessarily? It is something exciting to know some of its details.\nImage source\nLet’s tell of a story of a codebase that illustrates this.\nFirst let’s define a function that takes a callback. It would add two numbers together, then pass the result to a function defined as the third argument, clear enough? I believe!\nconst sumTwoNumbers = (a, b, doneCB) =\u003e doneCB(a + b) Next, let’s determine an Array of numbers but try\nconst numbers = Array(1, 2, 3, 4, 5) Now, we can add up the numbers successively using Array.prototype.forEach:\nconst totalAdditions = 0 numbers.forEach((number, index) =\u003e { sumTwoNumbers(number, numbers[index + 1], (total) =\u003e { totalAdditions += total }) }) As seen above, we are just two levels deep into the callback calls, and it is not getting any interesting. It should be noted that as the callback levels increase, the risk of hitting a re-initialization of variables increases. The first callback might have initialized numbers re-initializing it might disrupt the logic of the code, who knows?\nAnd looking at an example from the below image, we can see that it can get so uninteresting in larger applications.\nPromises to the rescue Eric Elliott: A promise is an object that may produce a single value some time in the future: either a resolved value, or a reason that it’s not resolved (e.g., a network error occurred).\nIn JavaScript, Promises have made the life of programmers more easier in handling asynchronous code. With Promises, most of the underlying problems like callback hells are waved out.\nPromises has a very interesting background in JavaScript, Eric Elliott gave has a great information about promises, regarding that, a promise could be constructed in a few lines of code:\nlet promise = new Promise(function (resolve, reject) { // executor }) In constructing a promise, we call the Promise constructor with a function called the executor. This function(executor) receives two arguments labeled as resolve and reject, both of which are functions.\nThe resolve argument is expected to be called with a value resolve(value) only when the executor has finished doing its tasks without any error. While the reject is expected to be called with a value (usually of type Error) reject(error) only if the promise failed or faced an error.\nlet promise = new Promise(function (resolve, reject) { try { const value = 2 * 2 resolve(value) } catch (e) { reject(e) } }) There are three (3) notable methods for every Promise object.\n.then() Accepts a function that receives the value passed when resolve is called by the executor. Only get called when the executor calls resolve. .catch() Accepts a function that receives the value passed when reject is called by the executor. Only get called when the executor calls reject. .finaly() The object returned by every initialization of a Promise constructor has some special attributes and methods. One of this is the status promise.status property, which tells about the current state of the Promise.\nThe status properties has three (3) possible values:\nPending: This is a state before resolve() is called. Resolved: This is a state after resolve() has been called. Rejected: This is a state after reject() has been called, or an error is thrown in the executing function. Promise are chainable, hence, every .then() called on a promise object returns another promise.\nconst promise = new Promise(function (resolve, reject) { try { const value = 2 * 2 resolve(value) } catch (e) { reject(e) } }) // Consuming the promise promise .then((value) =\u003e value * 4) .then((value) =\u003e value * 6) .then((value) =\u003e console.log(value)) While consuming the promise, every resolver in the .then() function returns a value until the last call to .then(). Failure to do this as we have done in the last call of .then() would make the next call to .then() receive an undefined.\n// Consuming the promise promise .then((value) =\u003e value * 4) .then((value) =\u003e value * 6) .then((value) =\u003e console.log(value)) .then((value) =\u003e console.log(value) /* -\u003e undefined */) We can use the finally in many different ways since it is called irrespective of the state of the Promise. The most obvious case of using it is when we need to hide a loading icon to show a message for the result of the action that has just been carried out.\npromise .finally(() =\u003e { document.querySelector(\".loading-icon\").remove() }) .then((data) =\u003e { // consume data }) .catch((err) =\u003e { // Show error }) There is more to Promises, this only gives a preamble and brief introduction to it, a thorough explanation could be found here\nAsync / Await It is not surprising to note that, for some unknown reasons that are best known to developers, they want Promises to be synchronous.\nThey found themselves in a situation where they need the result of a Promise to be available before they proceed to the next chunk of code - Either it is a network request, or a result from an extensive math function, they just needed the result to be available right in the next line of their code.\nTo solve this for them, the folks at TC39 gave us Async/Await.\nThis feature assists in constructing a promise right from a function, and we could wait for the result of a Promise before moving to the next line of code.\nconst getNumber = () =\u003e { return async () =\u003e { return 20 } } const result = await getNumber() Looking closely at the code above, we could see that the getNumber function returns an async function(a Promise), but why not make the returned function the primary function for getNumber?\nNo, we can not. JavaScript does not support making a global function an async function; the best we can do is wrap it in a containing function and make the inner function returns an async function. If we need a global function to be a Promise, it is best that we use a Promise constructor to define it.\nWhen we called const result = await getNumber(), we are telling the engine not to run any other code until we have the result from the Promise returned by getNumber, in this case, 20. If we omit await from that expression, following code will run while running the Promise returned by getNumber in the background.\nIn my honest opinion, I see async as syntactic sugar to constructing a Promise on the fly. If we would want to attempt to have the getNumber as a promise constructor instead of an async/await we would have:\nconst getNumber = new Promise(function (resolve, reject) { try { setTimeout(() =\u003e resolve(20), 60 * 1000) } catch (e) { reject(e) } }) In the above code, we have waited for about 1minute for the promise to be resolved if at all no error is thrown in our executor.\nDo you want to learn more about Async/Await and be a Ninja of asynchronous javascript? Try seeing the MDN guide on the topic.\nConclusion As seen above, we can deduce that the underlying engine of JavaScript supports asynchronous coding. At the same time, this is great; it created some problems for developers trying to make their code asynchronous.\nAs a solution to the challenge, Promise was introduced into the language, which was followed by the inclusion of Async/Await construct.\nIn my honest opinion, writing Async/Await in my codebases has made my code not just readable, but very predictable.\nSo, to asynchronous Javascript coding, I highly recommend understanding Promises and Async/Await construct if at all we want our future self and other developers to say a prayer when they see our code after we write it.\nShalom!\n","wordCount":"2490","inLanguage":"en","datePublished":"2020-03-03T00:00:00Z","dateModified":"2020-03-03T00:00:00Z","author":{"@type":"Person","name":"AI"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://limistah.dev/posts/asynchronous-javascript/"},"publisher":{"@type":"Organization","name":"limistah","logo":{"@type":"ImageObject","url":"https://limistah.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://limistah.dev accesskey=h title="limistah (Alt + H)">limistah</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://limistah.dev/blog title=Blog><span>Blog</span></a></li><li><a href=https://limistah.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://limistah.dev>Home</a>&nbsp;»&nbsp;<a href=https://limistah.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Asynchronous Javascript</h1><div class=post-meta><span title='2020-03-03 00:00:00 +0000 UTC'>March 3, 2020</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;AI&nbsp;|&nbsp;<a href=https://github.com/limistah/limistah.xyz/tree/main/content/posts/asynchronous-javascript.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#a-real-life-case-study aria-label="A real life case study">A real life case study</a></li><li><a href=#asynchrony-in-javascript aria-label="Asynchrony in JavaScript">Asynchrony in JavaScript</a></li><li><a href=#callbacks aria-label=Callbacks>Callbacks</a><ul><li><a href=#good-oldays-of-ajax aria-label="Good Ol&rsquo;days of AJAX">Good Ol&rsquo;days of AJAX</a></li><li><a href=#callback-hell aria-label="Callback Hell">Callback Hell</a></li></ul></li></ul><li><a href=#promises-to-the-rescue aria-label="Promises to the rescue">Promises to the rescue</a><ul><li><a href=#async--await aria-label="Async / Await">Async / Await</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>In computation systems, names like concurrent, sequential, parallel, serial, synchronous, asynchronous, non-blocking, shared state, message passing, and likes, stand as a forbearer for the actual task that happens in a system.</p><p>While all of the above techniques have their use cases, in the world of JavaScript, asynchronous and synchronous programming never leave the tongues of its programmers.</p><p>In his <a href="https://slikts.github.io/concurrency-glossary/?id=asynchronous-vs-synchronous-non-blocking-concurrent-vs-blocking-sequential"><strong>Concurrency glossary</strong></a>, <strong>slikts (<a href=mailto:dabas@untu.ms>dabas@untu.ms</a>)</strong> wrote about asynchronous, he said:</p><blockquote><p>Asynchrony means &ldquo;not happening at the same time&rdquo;, and asynchronous message passing is a communication model that does not require the sending and receiving to be synchronized, meaning that the sender isn&rsquo;t blocked until the receiver is ready.</p></blockquote><p>It might not be clear; still, we will go into a later detail about this with a real-life example. <em>Don&rsquo;t tell anyone, life is mostly asynchronous</em>.</p><p>While languages like Java, C#, C++, etc. run their computation on their main thread and could <em>spawn</em> out a new thread to run another set of instructions which are in parallel to the main thread and could also communicate with it. JavaScript, in its uniqueness, does not support that model of computation.</p><p>In JavaScript, all computations and instructions run in a <a href="https://slikts.github.io/concurrency-glossary/?id=concurrent-order-independent-vs-sequential">sequence</a> (i.e., one after another) in a single thread. This means that for instructions ranging from A, B, C, D, E to be executed, A would be executed first and when done, B is then executed, then C, then D, then E, which sees the program to its end.</p><p><img loading=lazy src=/assets/maxresdefault.jpg alt="https://www.youtube.com/watch?v=2ZH_1d8TYVg"></p><p>Still, with the single-threaded nature of JavaScript, there is a unique feature that makes it outstanding, it is its <strong>non-blocking I/O</strong> model.</p><p><em>I/O(Input/Output)</em> could be in any form, like fetching of data over the internet, getting a file from the filesystem and likes, all of these processes does not block the main thread from continuing its execution.</p><h3 id=a-real-life-case-study>A real life case study<a hidden class=anchor aria-hidden=true href=#a-real-life-case-study>#</a></h3><hr><blockquote><p>In high school, when students are given an assignment, they are required to submit it. Once they submit the task to the teacher, they are expected to wait until their books are returned back to them already marked/graded.</p></blockquote><blockquote><p>While they had submitted the assignments and are waiting for the results, they could do other things like reading, attend classes, play games, and joke with friends.</p></blockquote><blockquote><p>Once the teacher is done marking, the students are notified, then they would go to the teacher to pick them up, completing the process.</p></blockquote><hr><p>In this scenario, the students have done a task asynchronously. While the teacher could only do one thing at a time, they have asked the teacher to teach them and still mark their assignments.</p><p>The teacher could not complete both of them at the same time, so they would have to wait, but, set a trigger (through the class rep/governor) that made them know that the assignments are ready and the results are out.</p><p>The notification could help the students to determine what next to do. Maybe, to proceed with putting their books into their bags or doing the corrections or learning from other classmates. (<strong>whatever is next</strong>)</p><p>That is what happens in asynchronous programming.</p><h3 id=asynchrony-in-javascript>Asynchrony in JavaScript<a hidden class=anchor aria-hidden=true href=#asynchrony-in-javascript>#</a></h3><p>JavaScript as a language comes with support for asynchronous programming; there have been different ways to come up with this. Most common is the callbacks, which could be seen in many legacy code bases.</p><p>In the modern JavaScript engine, there is an added support for writing asynchronous code. We would be exploring these options and their demerits, and I would conclude with why I think that Async/Await as a feature of the language is too essential to understand. Let&rsquo;s hit the start knob.</p><h3 id=callbacks>Callbacks<a hidden class=anchor aria-hidden=true href=#callbacks>#</a></h3><p>For seasoned developers, this might seem like unveiling a nightmare following their experiences with <em>callback hell</em>. But, a callback is not that bad.</p><p>A callback is a function passed during a function call/invocation to be executed when the called function determines. A basic example is what <code>setTimeout</code>, <code>setInterval</code> do. Once any of them get called, it takes the function and executes it at the specified time passed from their second argument.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;This is a callback 1 sec. setTimeout test&#34;</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>setInterval</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;This is a callback 1 sec. setInterval test&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>  <span class=mi>1000</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>The two function calls above receive a callback as their first argument and execute it once they each reach the time (1sec) in their second argument. They will never obstruct the main thread from continuing executing other functions; instead, an entry is made in the call stack to take care of this.</p><p>Another great example is in the DOM Events API. A basic <code>onclick</code> event could be listened to like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>button</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;#submitButton&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>button</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&#34;click&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Submit Button Clicked&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>Once the button is clicked, with the single thread nature of JavaScript, one would expect that the above code should work like this:</p><ul><li>Store the DOM reference of <code>submitButton</code> to the <code>button</code> variable.</li><li><code>button.addEventListener</code> is called which puts in an entry into the call stack</li><li>The event is registered against a <code>click</code> name, and the code for the <code>addEventListener</code> is executed.</li><li>Once it is executed, the function/handler should be triggered immediately in the <code>addEventListener</code> execution context</li></ul><p>As stated in the above, we expect all of those to happen in parallel. But, what happens there is that code and functions are delegated to a later time when an actual action has happened. Recall the <a href=a-real-life-case-study>High School Assignment</a> illustration we gave?</p><p>What happens is that:</p><blockquote><p>Once the <code>click</code> event has been triggered on the button, the function would be executed. And this could happen any time in the future, but other code could still run while waiting for this.</p></blockquote><h4 id=good-oldays-of-ajax>Good Ol&rsquo;days of AJAX<a hidden class=anchor aria-hidden=true href=#good-oldays-of-ajax>#</a></h4><p>With the myriads of NPM libraries that make this happen in a few lines of JS code. Also, the inclusion of the <em>fetch</em> API to the modern JavaScript engines has made this to be so uncommon to the modern developers what AJAX means right in the browser, as they take away the underlying fact about AJAX web requests.</p><p>Before the days of EcmaScript 6, while developers still really disliked working with JavaScript (<em>which is unavoidable for web developers, though</em> 😄), web requests could be made over the internet through an XMLHTTPRequest object. The technique for making this request was later formed to be called <strong>Asynchronous JavaScript and XML</strong>, popularly known as <strong>AJAX</strong>.</p><p>What AJAX means is that we could request the internet, wait for the result to come while still having other things going on in the browser (basically, a loading icon). This is asynchronous in nature, and the main reason why it is called <code>AJAX</code>.</p><p>AJAX uses the callback model, a basic <em>vanilla</em> AJAX request using the XMLHTTPRequest object looks like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Picked from https://www.w3schools.com/xml/xml_http.asp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>xhttp</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>XMLHttpRequest</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>xhttp</span><span class=p>.</span><span class=nx>onreadystatechange</span> <span class=o>=</span> <span class=kd>function</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>readyState</span> <span class=o>==</span> <span class=mi>4</span> <span class=o>&amp;&amp;</span> <span class=k>this</span><span class=p>.</span><span class=nx>status</span> <span class=o>==</span> <span class=mi>200</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Typical action to be performed when the document is ready:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;demo&#34;</span><span class=p>).</span><span class=nx>innerHTML</span> <span class=o>=</span> <span class=nx>xhttp</span><span class=p>.</span><span class=nx>responseText</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>xhttp</span><span class=p>.</span><span class=nx>open</span><span class=p>(</span><span class=s2>&#34;GET&#34;</span><span class=p>,</span> <span class=s2>&#34;filename&#34;</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>xhttp</span><span class=p>.</span><span class=nx>send</span><span class=p>()</span>
</span></span></code></pre></div><p><em>It is not attractive, I know. If you are a modern JavaScript developer, respect those that have passed through this and still look uncool to you, this was so cool to them back then.</em></p><p>This AJAX feature utilized the model of event handling and was very easy to comprehend by JavaScript developers. But, it shares a similar problem with all callback-based coding patterns/techniques.</p><h4 id=callback-hell>Callback Hell<a hidden class=anchor aria-hidden=true href=#callback-hell>#</a></h4><p>Does it mean hell in our code/machines, well, not necessarily? It is something exciting to know some of its details.</p><p><img loading=lazy src=/assets/callbackhell.png alt="Callback hell"></p><blockquote><blockquote><p><a href=https://lh3.googleusercontent.com/proxy/DOxEQlABD3FPPagO7xG_D-3Go3PPOjqbhsUljaM7bpZwmRs9Ep3flHBoCK8c2p_yU_Nilh5Dh8l3M-Ct75Jfhb7lnCvYgPqtj1Tekw>Image source</a></p></blockquote></blockquote><p>Let&rsquo;s tell of a story of a codebase that illustrates this.</p><p>First let&rsquo;s define a function that takes a callback. It would add two numbers together, then pass the result to a function defined as the third argument, clear enough? I believe!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sumTwoNumbers</span> <span class=o>=</span> <span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>doneCB</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>doneCB</span><span class=p>(</span><span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>)</span>
</span></span></code></pre></div><p>Next, let&rsquo;s determine an Array of numbers but try</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>numbers</span> <span class=o>=</span> <span class=nb>Array</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span></code></pre></div><p>Now, we can add up the numbers successively using <code>Array.prototype.forEach</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>totalAdditions</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=nx>numbers</span><span class=p>.</span><span class=nx>forEach</span><span class=p>((</span><span class=nx>number</span><span class=p>,</span> <span class=nx>index</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>sumTwoNumbers</span><span class=p>(</span><span class=nx>number</span><span class=p>,</span> <span class=nx>numbers</span><span class=p>[</span><span class=nx>index</span> <span class=o>+</span> <span class=mi>1</span><span class=p>],</span> <span class=p>(</span><span class=nx>total</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>totalAdditions</span> <span class=o>+=</span> <span class=nx>total</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>As seen above, we are just two levels deep into the callback calls, and it is not getting any interesting. It should be noted that as the callback levels increase, the risk of hitting a re-initialization of variables increases. The first callback might have initialized <code>numbers</code> re-initializing it might disrupt the logic of the code, who knows?</p><p>And looking at an example from the below image, we can see that it can get so uninteresting in larger applications.</p><h2 id=promises-to-the-rescue>Promises to the rescue<a hidden class=anchor aria-hidden=true href=#promises-to-the-rescue>#</a></h2><blockquote><blockquote><p><a href=https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261><strong>Eric Elliott</strong></a>:
A promise is an object that may produce a single value some time in the future: either a resolved value, or a reason that it’s not resolved (e.g., a network error occurred).</p></blockquote></blockquote><p>In JavaScript, Promises have made the life of programmers more easier in handling asynchronous code. With Promises, most of the underlying problems like callback hells are waved out.</p><p>Promises has a very interesting background in JavaScript, <a href=https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261>Eric Elliott</a> gave has a great information about promises, regarding that, a promise could be constructed in a few lines of code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// executor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>})</span>
</span></span></code></pre></div><p>In constructing a promise, we call the Promise constructor with a function called the <em>executor</em>. This function(executor) receives two arguments labeled as <code>resolve</code> and <code>reject</code>, both of which are functions.</p><p>The <code>resolve</code> argument is expected to be called with a value <code>resolve(value)</code> only when the executor has finished doing its tasks without any error. While the <code>reject</code> is expected to be called with a value (usually of type Error) <code>reject(error)</code> only if the promise failed or faced an error.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>value</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nx>resolve</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>reject</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>There are three (3) notable methods for every Promise object.</p><ul><li><code>.then()</code> Accepts a function that receives the value passed when <code>resolve</code> is called by the executor. Only get called when the executor calls <code>resolve</code>.</li><li><code>.catch()</code> Accepts a function that receives the value passed when <code>reject</code> is called by the executor. Only get called when the executor calls <code>reject</code>.</li><li><code>.finaly()</code></li></ul><p>The object returned by every initialization of a Promise constructor has some special attributes and methods. One of this is the <em>status</em> <code>promise.status</code> property, which tells about the current state of the Promise.</p><p>The <em>status</em> properties has three (3) possible values:</p><ul><li>Pending: This is a state before <code>resolve()</code> is called.</li><li>Resolved: This is a state after <code>resolve()</code> has been called.</li><li>Rejected: This is a state after <code>reject()</code> has been called, or an error is thrown in the executing function.</li></ul><p>Promise are chainable, hence, every <code>.then()</code> called on a promise object returns another promise.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>const</span> <span class=nx>value</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>*</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nx>resolve</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>reject</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Consuming the promise
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>promise</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>value</span> <span class=o>*</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>value</span> <span class=o>*</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>))</span>
</span></span></code></pre></div><p>While consuming the promise, every resolver in the <code>.then()</code> function returns a value until the last call to <code>.then()</code>. Failure to do this as we have done in the last call of <code>.then()</code> would make the next call to <code>.then()</code> receive an <code>undefined</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Consuming the promise
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>promise</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>value</span> <span class=o>*</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>value</span> <span class=o>*</span> <span class=mi>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>value</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=cm>/* -&gt; undefined */</span><span class=p>)</span>
</span></span></code></pre></div><p>We can use the finally in many different ways since it is called irrespective of the state of the Promise. The most obvious case of using it is when we need to hide a loading icon to show a message for the result of the action that has just been carried out.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>promise</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>finally</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nb>document</span><span class=p>.</span><span class=nx>querySelector</span><span class=p>(</span><span class=s2>&#34;.loading-icon&#34;</span><span class=p>).</span><span class=nx>remove</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=nx>then</span><span class=p>((</span><span class=nx>data</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// consume data
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>})</span>
</span></span><span class=line><span class=cl>  <span class=p>.</span><span class=k>catch</span><span class=p>((</span><span class=nx>err</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Show error
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>})</span>
</span></span></code></pre></div><p>There is more to Promises, this only gives a preamble and brief introduction to it, a thorough explanation could be found <a href=https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261>here</a></p><h3 id=async--await>Async / Await<a hidden class=anchor aria-hidden=true href=#async--await>#</a></h3><p>It is not surprising to note that, for some unknown reasons that are best known to developers, they want Promises to be synchronous.</p><p>They found themselves in a situation where they need the result of a Promise to be available before they proceed to the next chunk of code - Either it is a network request, or a result from an extensive math function, they just needed the result to be available right in the next line of their code.</p><p>To solve this for them, the folks at <a href=https://tc39.es/>TC39</a> gave us <a href=https://github.com/tc39/ecmascript-asyncawait>Async/Await</a>.</p><p>This feature assists in constructing a promise right from a function, and we could wait for the result of a Promise before moving to the next line of code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>getNumber</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kr>async</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>20</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>getNumber</span><span class=p>()</span>
</span></span></code></pre></div><p>Looking closely at the code above, we could see that the <code>getNumber</code> function returns an async function(a Promise), but why not make the returned function the primary function for <code>getNumber</code>?</p><p>No, we can not. JavaScript does not support making a global function an <code>async</code> function; the best we can do is wrap it in a containing function and make the inner function returns an <code>async</code> function. If we need a global function to be a Promise, it is best that we use a Promise constructor to define it.</p><p>When we called <code>const result = await getNumber()</code>, we are telling the engine not to run any other code until we have the result from the Promise returned by <code>getNumber</code>, in this case, 20. If we omit <code>await</code> from that expression, following code will run while running the Promise returned by <code>getNumber</code> in the background.</p><p>In my honest opinion, I see <code>async</code> as syntactic sugar to constructing a Promise on the fly. If we would want to attempt to have the getNumber as a promise constructor instead of an <code>async/await</code> we would have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>getNumber</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=kd>function</span> <span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>20</span><span class=p>),</span> <span class=mi>60</span> <span class=o>*</span> <span class=mi>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>catch</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>reject</span><span class=p>(</span><span class=nx>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>In the above code, we have waited for about 1minute for the promise to be resolved if at all no error is thrown in our executor.</p><p>Do you want to learn more about Async/Await and be a Ninja of asynchronous javascript? Try seeing the <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function>MDN guide</a> on the topic.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>As seen above, we can deduce that the underlying engine of JavaScript supports asynchronous coding. At the same time, this is great; it created some problems for developers trying to make their code asynchronous.</p><p>As a solution to the challenge, Promise was introduced into the language, which was followed by the inclusion of Async/Await construct.</p><p>In my honest opinion, writing Async/Await in my codebases has made my code not just readable, but very predictable.</p><p>So, to asynchronous Javascript coding, I highly recommend understanding Promises and Async/Await construct if at all we want our <em>future self</em> and <em>other developers</em> to say a prayer when they see our code after we write it.</p><p><em>Shalom!</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://limistah.dev/tags/js/>JS</a></li></ul><nav class=paginav><a class=prev href=https://limistah.dev/posts/socketio-app-structure/><span class=title>« Prev</span><br><span>SocketIO - App structure and architecture</span>
</a><a class=next href=https://limistah.dev/posts/wordpress-like-menu-node-apps/><span class=title>Next »</span><br><span>Menu system in Node Apps like WordPress Menu</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on x" href="https://x.com/intent/tweet/?text=Asynchronous%20Javascript&amp;url=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f&amp;hashtags=JS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f&amp;title=Asynchronous%20Javascript&amp;summary=Asynchronous%20Javascript&amp;source=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f&title=Asynchronous%20Javascript"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on whatsapp" href="https://api.whatsapp.com/send?text=Asynchronous%20Javascript%20-%20https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on telegram" href="https://telegram.me/share/url?text=Asynchronous%20Javascript&amp;url=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Asynchronous Javascript on ycombinator" href="https://news.ycombinator.com/submitlink?t=Asynchronous%20Javascript&u=https%3a%2f%2flimistah.dev%2fposts%2fasynchronous-javascript%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://limistah.dev>limistah</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>