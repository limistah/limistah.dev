<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dockerized Node/Nginx, MongoDB, Redis app setup | limistah</title>
<meta name=keywords content="JS"><meta name=description content="Introduction Docker is an app development tool that eases the process of creating, running, and deploying applications. It uses the concept of containers which work just like a Virtual Machine does.
While Docker runs more like a Virtual Machine does, it is more advantageous than a VM.
It let us define OS-like images like we are writing an actual OS that includes the only tools that we need, aside this, Docker utilizes the concept of layers which makes its images very much extensible."><meta name=author content="AI"><link rel=canonical href=https://limistah.dev/posts/docker-node-nginx-redis-mongodb/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://limistah.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://limistah.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://limistah.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://limistah.dev/apple-touch-icon.png><link rel=mask-icon href=https://limistah.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Dockerized Node/Nginx, MongoDB, Redis app setup"><meta property="og:description" content="Introduction Docker is an app development tool that eases the process of creating, running, and deploying applications. It uses the concept of containers which work just like a Virtual Machine does.
While Docker runs more like a Virtual Machine does, it is more advantageous than a VM.
It let us define OS-like images like we are writing an actual OS that includes the only tools that we need, aside this, Docker utilizes the concept of layers which makes its images very much extensible."><meta property="og:type" content="article"><meta property="og:url" content="https://limistah.dev/posts/docker-node-nginx-redis-mongodb/"><meta property="og:image" content="https://limistah.dev/images/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-19T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-19T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://limistah.dev/images/papermod-cover.png"><meta name=twitter:title content="Dockerized Node/Nginx, MongoDB, Redis app setup"><meta name=twitter:description content="Introduction Docker is an app development tool that eases the process of creating, running, and deploying applications. It uses the concept of containers which work just like a Virtual Machine does.
While Docker runs more like a Virtual Machine does, it is more advantageous than a VM.
It let us define OS-like images like we are writing an actual OS that includes the only tools that we need, aside this, Docker utilizes the concept of layers which makes its images very much extensible."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://limistah.dev/posts/"},{"@type":"ListItem","position":2,"name":"Dockerized Node/Nginx, MongoDB, Redis app setup","item":"https://limistah.dev/posts/docker-node-nginx-redis-mongodb/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dockerized Node/Nginx, MongoDB, Redis app setup","name":"Dockerized Node\/Nginx, MongoDB, Redis app setup","description":"Introduction Docker is an app development tool that eases the process of creating, running, and deploying applications. It uses the concept of containers which work just like a Virtual Machine does.\nWhile Docker runs more like a Virtual Machine does, it is more advantageous than a VM.\nIt let us define OS-like images like we are writing an actual OS that includes the only tools that we need, aside this, Docker utilizes the concept of layers which makes its images very much extensible.","keywords":["JS"],"articleBody":"Introduction Docker is an app development tool that eases the process of creating, running, and deploying applications. It uses the concept of containers which work just like a Virtual Machine does.\nWhile Docker runs more like a Virtual Machine does, it is more advantageous than a VM.\nIt let us define OS-like images like we are writing an actual OS that includes the only tools that we need, aside this, Docker utilizes the concept of layers which makes its images very much extensible. With this little feature, developers, sysadmins and devops engineers prefer it more. And since it has been in existence, Docker has witnessed widespread usages making it one of the defacto tool for software development, testing and delivery.\nWhile there are many low level details about Docker which we wonâ€™t be doing in this post. In this post, we will focus on creating a docker compose file that could ease the development and deployment of NodeJS based web applications which require an nginx server which acts as a proxy server to a NodeJS application, MongoDB as the database and Redis as its dependencies.\nBase Dockerfile First, we will define a Dockerfile this is a file that Docker reads to create an image which could be used to start a container.\nThis file has some interesting commands but we are only interested in a few. This file should look like below:\n# Base Image. # This image already exists in dockerhub. # We are just extending its functionalities FROM node:10 # Already created by the node image USER node # Changes directory in the container to this directory WORKDIR /home/node/app # Port that the node app will listen to EXPOSE 8000 The above Dockerfile commands is what we can use when we are defining an image. Images are typical to installing a fresh operating system, instead of having a full OS on a different machine, Docker builds this image to work with any computer without installing it.\nAn operating system image inside of another OS is not new, it could be found in Virtual Machine implementations. What they do is utilize a feature of computers called HyperV, it is\nSo, in our Dockerfile, we are calling a few commands that Docker could understand to create a new image for us. A brief explanation about the used commands:\nFROM: It inherits from another image, builds untop of it, making it easier to make modifications. USER: Sets the user that is associated with the current session inside of an interactive terminal in case we need one. WORKDIR: Sets the default directory that a terminal would be when it is initialized. EXPOSE: The image can receive connections, but could only be connected to by containers in the same network, except it is told to expose the port to the host machine. This command exposes a port of an image to its host machine. So, this is complete in our case. An OS with NodeJS, and we know a directory to put our source codes inside of the image, interesting.\nNext, we have to build this image to confirm if we the Dockerfile contains a valid syntax.\nTo build a Docker Image from a directory that has a Dockerfile - like ours, we can run:\ndocker image build -t nodejs This would pull the NodeJS image from hub.docker.com then run the remaining commands to modify for our new image. When this is done, we could verify by running:\ndocker image ls The above command would list the images currently installed locally.\nIf that works, we have successfully build our nodejs image, and we can now create containers that uses the images.\nContainers are like the computer itself, they run using an image just like our physical computers run using an operating system. In Docker, think of Images like an installable operating system, while containers to be the machine that can install an operating system, in this case an image.\nTo have a container running using the nodejs image, we can use the below command:\ndocker container start -it --name nodejs-container nodejs The command above is starting a container, gives the container a name of nodejs, run it interactively, then use the nodejs image that we built earlier.\nThe result of the command above is a nodejs repl being launched in our terminal.\nWe are seeing that because that is what the parent image(nodejs) specified. In its Dockerfile it specifies CMD: node. We can override this easily in our docker file, but that is not a good idea, we want this setup to be reusable so we should leave that as it is. There is a better way to override it which would not require modifying the Dockerfile.\nNginx Dockerfile As a rule of thumb, we can only have one Dockerfile in a directory, and we have used that opportunity to make that file build a NodeJS image for us. But, we also need to build an nginx image from a parent image on DockerHub which would receive http requests like our webserver would.\nWhy we need an Nginx image is to bootstrap an Nginx server that would mimic our production live server. What Nginx server does in NodeJS deployments is to create a proxy against the actual node server from the rest of the world.\nLocal User â€“\u003e Our Web Server â€“\u003e Node App inside the server.\nLocal User \u003câ€“ Our Web Server \u003câ€“ Node App inside the server\nFor us to achieve this architecture Dockerized, it is essential we build an image off the official nginx image from DockerHub. Letâ€™s do this!\nLetâ€™s create a file named nginx.Dockerfile in the same directory, and have the content as below:\nFROM nginx:1.13 COPY nginx.conf /etc/nginx/conf.d/default.conf This is quite smaller to that of the NodeJS, but would do a full build process of the nginx image. This is the power of Docker, when we extend an image, we can add special functionalities to the image, which leaves us from the low-level details that is associated with creating that image.\nIn this nginx Dockefile, we are extending the official nginx image at version 1.13, then copying a file nginx.conf to the default nginx config path. The copy command is to ensure that we make our nginx do what we want when we are ready to create our proxy server.\nAwesome!\nNext, we can build this image as we have built the NodeJSâ€™ to very our syntaxt. But before we build, letâ€™s add a file at the same location named nginx.conf. This file should have the following content:\nserver { listen 80; location / { proxy_pass http://localhost:5000; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Host $server_name; } } As should be noticed in the nginx.conf file, we are redirecting all traffic coming to this server to another address(http://localhost:5000), we are assuming an app is running at this port. Now we can build the nginx Dockerfile to a Docker image with:\ndocker image build -t nginx -f nginx.Dockefile We have to specify the -f nginx.Dockerfile to tell Docker to not use the default Dockerfile which is for our nodejs image.\nAnd running a container off of the image:\ndocker container start -it --name nginx-container -p 80:80 nginx Perfect! We now have a proxy nginx server that routes request to its 127.0.0.1:5000. As we know, images are OS of their own, and the nginx would resolves localhost to itself, we donâ€™t want it to route to itself since our nodejs app would live in the nodejs container. We will later provide a solution to this.\nMongoDB and Redis Dockerfiles We wonâ€™t be building an image for MongoDB and Redis, the major reason is that we donâ€™t have any customization to add to the image that we would be inheriting from. So, it is more of over-engineering to have a dockerfile that contains:\nFROM mongodb:alpine When we can have a docker-compose file to take away that for us or create a container on the image which would be pulled from dockerhub.\nDocker-Compose Composability is one of the many features that Distinguishes Docker from a VM. From Compose we should understand that we can create many images, containers, networks, drives on the fly in just one file. This helps with maintainance and helps to conceptualize software as a mixture of dependencies in their uniqueness.\nSo, letâ€™s compose an architecture for NodeJS, Nginx, Mongo and Redis!\nIn the same directory, create a file named docker-compose.yml, compose files are YAML files with commands that the docker-compose command understands.\nOnce that file is created, letâ€™s define some images that we would be needing for our architecture. First, I will define the nodejs image, making the first version of docker-compose.yml file to look like this:\nversion: \"2\" services: node: build: context: . dockerfile: Dockerfile volumes: - ./:/home/node/app command: \"npm start\" ports: - 5000:5000 In the snippet above, we are trying to create a node image through this compose file from the Dockerfile we defined above, (the context is the path to look for, while the dockerfile is a customized name for our Dockerfile, we can omit it since our nodejs Dockerfile has the default naming convention, but, we have added it for clarity sake).\nAlso, we could notice we were setting some information, if you can remember when how we create containers: docker container run --name nginx -p 80:80 nginx, we can pass parameters and further extend the image through these commands.\nHere we can see that we have forwared port 5000 from the container to the containerâ€™s 5000, map the current directory to the /home/node/app folder in the container and how we could specify the command we want to run after the container might have been started? That is the power of compose files. To know more about the commands that can be passed, see the docker-compose documentation\nNow testing our compose file, we can start the compose file in docker and not forget, as docker to build us the nodejs image since we have specified the build command:\ndocker-compose up --build That is it, we have our first docker-compose running!\nNext, we should include our nginx config into the docer-compose file. Which would make our docker-compose.yml to look like this:\nversion: \"2\" services: node: build: context: . dockerfile: node.Dockerfile volumes: - ./:/home/node/app command: \"npm start\" ports: - 5000:5000 networks: # notice this addition to the node servic - nginx-proxy # notice this - default # notice this nginx: build: context: . dockerfile: nginx.Dockerfile volumes: - ./:/home/node/app # command: \"npm start\" restart: always ports: - 80:80 depends_on: - node networks: - nginx-proxy - default networks: nginx-proxy: With this update, we have included the nginx.Dockerfile to build an nginx image for us which should include the nginx.conf we have. To be noticed in the bginx service is depends_on , this commands ensures that the node is started and running before nginx is started. We also added the both services to the same networks so they can communicate using their service name instead of their respective virtual ips.\nFor ngix.conf to work, we have to update the part that redirects to localhost:5000 to redirect to http://node:5000. The node hostname would be resolved to virtual ip address by Docker during runtime. This change should make our nginx.conf to look like this:\nserver { listen 80; location / { proxy_pass http://node:5000; # updated from localhost to the service name proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Host $server_name; } } Awesome, we can build these two services and run them at the same time as we did before using: docker-compose up --build. Both services running? Great!\nIf the node service is failing, do init a node project in the root directory with: npm ini -y and add a start script OR remove the command: npm start from the docker-compose.yml file.\nWe are doing well!\nNext letâ€™s include Redis service into the compose file.\nversion: \"2\" services: node: build: context: . dockerfile: node.Dockerfile volumes: - ./:/home/node/app command: \"npm start\" ports: - 5000:5000 depends_on: - mongodb-server networks: - nginx-proxy - default nginx: build: context: . dockerfile: nginx.Dockerfile volumes: - ./:/home/node/app restart: always ports: - 80:80 depends_on: - node # network_mode: bridge networks: - nginx-proxy - default redis-server: image: \"redis:5.0.8-alpine\" ports: - \"6379:6379\" networks: nginx-proxy: It gets more interesting, but simply done. We donâ€™t need any special configuration or extension for the Redis Image. So, we just use the image: ... command instead of the build command to tell the image we want to use. This also means that docker will not build this image, rather download it from Dockerhub.\nFinally, a database. Letâ€™s add mongodb service to complete our setup.\nversion: \"2\" services: node: build: context: . # You can rename the file to make it tell what it does. # since we are composing different images and not just a sigle image dockerfile: node.Dockerfile volumes: - ./:/home/node/app command: \"npm start\" ports: - 5000:5000 depends_on: # We now depends on node and mongodb server - redis-server - mongodb-server networks: - nginx-proxy - default nginx: build: context: . dockerfile: nginx.Dockerfile volumes: - ./:/home/node/app restart: always ports: - 80:80 depends_on: - node networks: - nginx-proxy - default redis-server: image: \"redis:5.0.8-alpine\" ports: - \"6379:6379\" mongodb-server: image: \"mongo:4.2.3-bionic\" ports: - \"27017:27017\" networks: nginx-proxy: As simple as the redis service is, same with the mongodb service. We are downloading the image from github and running a mongodb-server container off it.\nGreat work!\nNow, we can test our setup as we always do: docker-compose up --build.\nSpeaking between containers. If we try to connect to the redis service from our node app we might get an error as the address 127.0.0.1 would mean the instance itself and not the host computer, same will happen with the mongodb service.\nTo solve this, we will add a service_name to every service we want to reference inside of another container, and ensure that the depends_on is updated to that new service name.\nSo our final config would look like this:\nversion: \"2\" services: node: server_name: node build: context: . # You can rename the file to make it tell what it does. # since we are composing different images and not just a sigle image dockerfile: node.Dockerfile volumes: - ./:/home/node/app command: \"npm start\" ports: - 5000:5000 depends_on: # We now depends on node and mongodb server - redis-server - mongodb-server networks: - nginx-proxy - default nginx: service_name: nginx build: context: . dockerfile: nginx.Dockerfile volumes: - ./:/home/node/app restart: always ports: - 80:80 depends_on: - node networks: - nginx-proxy - default redis-server: service_name: redis image: \"redis:5.0.8-alpine\" ports: - \"6379:6379\" mongodb-server: service_name: mongodb image: \"mongo:4.2.3-bionic\" ports: - \"27017:27017\" networks: nginx-proxy: Easy enough? Now in our source codes we can use http://redis:6379 to connect to redis service container and http://mongodb:27017 to connect to the mongodb service container.\nVoila!\nConclusion Finally, we cracked it. Walking through the journey from an empty file to a docker-compose.yml file that we can share with anyone that would love to replicate same setup for their development. This was so much fun to walk through.\nThere is more to Docker than we have covered, donâ€™t hesitate to read the docs for more information and commads that could be used in Dockerfile and docker-compose.yml files.\nPLEASE!!!\nDockerize yourself at this time, stay safe, stay home, stay in a containerized environment!!!\nOu re voir!\n","wordCount":"2553","inLanguage":"en","datePublished":"2020-03-19T00:00:00Z","dateModified":"2020-03-19T00:00:00Z","author":{"@type":"Person","name":"AI"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://limistah.dev/posts/docker-node-nginx-redis-mongodb/"},"publisher":{"@type":"Organization","name":"limistah","logo":{"@type":"ImageObject","url":"https://limistah.dev/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://limistah.dev accesskey=h title="limistah (Alt + H)">limistah</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://limistah.dev/blog title=Blog><span>Blog</span></a></li><li><a href=https://limistah.dev/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://limistah.dev>Home</a>&nbsp;Â»&nbsp;<a href=https://limistah.dev/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Dockerized Node/Nginx, MongoDB, Redis app setup</h1><div class=post-meta><span title='2020-03-19 00:00:00 +0000 UTC'>March 19, 2020</span>&nbsp;Â·&nbsp;12 min&nbsp;Â·&nbsp;AI&nbsp;|&nbsp;<a href=https://github.com/limistah/limistah.xyz/tree/main/content/posts/docker-node-nginx-redis-mongodb.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#base-dockerfile aria-label="Base Dockerfile">Base Dockerfile</a></li><li><a href=#nginx-dockerfile aria-label="Nginx Dockerfile">Nginx Dockerfile</a></li><li><a href=#mongodb-and-redis-dockerfiles aria-label="MongoDB and Redis Dockerfiles">MongoDB and Redis Dockerfiles</a></li><li><a href=#docker-compose aria-label=Docker-Compose>Docker-Compose</a></li><li><a href=#speaking-between-containers aria-label="Speaking between containers.">Speaking between containers.</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>Docker is an app development tool that eases the process of creating, running, and deploying applications. It uses the concept of containers which work just like a Virtual Machine does.</p><p>While Docker runs more like a Virtual Machine does, it is more advantageous than a VM.</p><p>It let us define OS-like images like we are writing an actual OS that includes the only tools that we need, aside this, Docker utilizes the concept of layers which makes its images very much extensible. With this little feature, developers, sysadmins and devops engineers prefer it more. And since it has been in existence, Docker has witnessed widespread usages making it one of the defacto tool for software development, testing and delivery.</p><p>While there are many low level details about Docker which we won&rsquo;t be doing in this post. In this post, we will focus on creating a docker compose file that could ease the development and deployment of NodeJS based web applications which require an nginx server which acts as a proxy server to a NodeJS application, MongoDB as the database and Redis as its dependencies.</p><h2 id=base-dockerfile>Base Dockerfile<a hidden class=anchor aria-hidden=true href=#base-dockerfile>#</a></h2><p>First, we will define a <code>Dockerfile</code> this is a file that Docker reads to create an image which could be used to start a container.</p><p>This file has some interesting <a href=https://docs.docker.com/engine/reference/builder/>commands</a> but we are only interested in a few. This file should look like below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># Base Image.</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># This image already exists in dockerhub.</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># We are just extending its functionalities</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> node:10</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Already created by the node image </span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>USER</span><span class=s> node</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Changes directory in the container to this directory</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /home/node/app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># Port that the node app will listen to</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>EXPOSE</span><span class=s> 8000 </span><span class=err>
</span></span></span></code></pre></div><p>The above Dockerfile commands is what we can use when we are defining an image. Images are typical to installing a fresh operating system, instead of having a full OS on a different machine, Docker builds this image to work with any computer without installing it.</p><p>An operating system image inside of another OS is not new, it could be found in Virtual Machine implementations. What they do is utilize a feature of computers called HyperV, it is</p><p>So, in our Dockerfile, we are calling a few commands that Docker could understand to create a new image for us. A brief explanation about the used commands:</p><ul><li><code>FROM</code>: It inherits from another image, builds untop of it, making it easier to make modifications.</li><li><code>USER</code>: Sets the user that is associated with the current session inside of an interactive terminal in case we need one.</li><li><code>WORKDIR</code>: Sets the default directory that a terminal would be when it is initialized.</li><li><code>EXPOSE</code>: The image can receive connections, but could only be connected to by containers in the same network, except it is told to expose the port to the host machine. This command exposes a port of an image to its host machine.</li></ul><p>So, this is complete in our case. An OS with NodeJS, and we know a directory to put our source codes inside of the image, interesting.</p><p>Next, we have to build this image to confirm if we the Dockerfile contains a valid syntax.</p><p>To build a Docker Image from a directory that has a Dockerfile - like ours, we can run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker image build -t nodejs
</span></span></code></pre></div><p>This would pull the NodeJS image from hub.docker.com then run the remaining commands to modify for our new image. When this is done, we could verify by running:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker image ls
</span></span></code></pre></div><p>The above command would list the images currently installed locally.</p><p>If that works, we have successfully build our nodejs image, and we can now create containers that uses the images.</p><blockquote><blockquote><blockquote><p>Containers are like the computer itself, they run using an image just like our physical computers run using an operating system. In Docker, think of Images like an installable operating system, while containers to be the machine that can install an operating system, in this case an image.</p></blockquote></blockquote></blockquote><p>To have a container running using the nodejs image, we can use the below command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker container start -it --name nodejs-container nodejs
</span></span></code></pre></div><p>The command above is starting a container, gives the container a name of nodejs, run it interactively, then use the nodejs image that we built earlier.</p><p>The result of the command above is a nodejs repl being launched in our terminal.</p><p>We are seeing that because that is what the parent image(nodejs) specified. In its Dockerfile it specifies <code>CMD: node</code>. We can override this easily in our docker file, but that is not a good idea, we want this setup to be reusable so we should leave that as it is. There is a better way to override it which would not require modifying the Dockerfile.</p><h2 id=nginx-dockerfile>Nginx Dockerfile<a hidden class=anchor aria-hidden=true href=#nginx-dockerfile>#</a></h2><p>As a rule of thumb, we can only have one Dockerfile in a directory, and we have used that opportunity to make that file build a NodeJS image for us. But, we also need to build an nginx image from a parent image on <a href=http://hub.docker.com/>DockerHub</a> which would receive http requests like our webserver would.</p><p>Why we need an Nginx image is to bootstrap an Nginx server that would mimic our production live server. What Nginx server does in NodeJS deployments is to create a proxy against the actual node server from the rest of the world.</p><blockquote><blockquote><blockquote><p>Local User &ndash;> Our Web Server &ndash;> Node App inside the server.</p></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>Local User &lt;&ndash; Our Web Server &lt;&ndash; Node App inside the server</p></blockquote></blockquote></blockquote><p>For us to achieve this architecture Dockerized, it is essential we build an image off the official nginx image from DockerHub. Let&rsquo;s do this!</p><p>Let&rsquo;s create a file named <code>nginx.Dockerfile</code> in the same directory, and have the content as below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-docker data-lang=docker><span class=line><span class=cl><span class=k>FROM</span><span class=s> nginx:1.13</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> nginx.conf /etc/nginx/conf.d/default.conf<span class=err>
</span></span></span></code></pre></div><p>This is quite smaller to that of the NodeJS, but would do a full build process of the nginx image. This is the power of Docker, when we extend an image, we can add special functionalities to the image, which leaves us from the low-level details that is associated with creating that image.</p><p>In this nginx Dockefile, we are extending the official nginx image at version 1.13, then copying a file <code>nginx.conf</code> to the default nginx config path. The copy command is to ensure that we make our nginx do what we want when we are ready to create our proxy server.</p><p>Awesome!</p><p>Next, we can build this image as we have built the NodeJS&rsquo; to very our syntaxt. But before we build, let&rsquo;s add a file at the same location named <code>nginx.conf</code>. This file should have the following content:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nginx data-lang=nginx><span class=line><span class=cl><span class=k>server</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kn>listen</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_pass</span>         <span class=s>http://localhost:5000</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_redirect</span>     <span class=no>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>Host</span> <span class=nv>$host</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>X-Real-IP</span> <span class=nv>$remote_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>X-Forwarded-For</span> <span class=nv>$proxy_add_x_forwarded_for</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>X-Forwarded-Host</span> <span class=nv>$server_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As should be noticed in the <code>nginx.conf</code> file, we are redirecting all traffic coming to this server to another address(<em>http://localhost:5000</em>), we are assuming an app is running at this port. Now we can build the nginx Dockerfile to a Docker image with:</p><pre tabindex=0><code>docker image build -t nginx -f nginx.Dockefile
</code></pre><blockquote><blockquote><p><strong>We have to specify the <code>-f nginx.Dockerfile</code> to tell Docker to not use the default Dockerfile which is for our nodejs image.</strong></p></blockquote></blockquote><p>And running a container off of the image:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker container start -it --name nginx-container -p 80:80 nginx
</span></span></code></pre></div><p>Perfect! We now have a proxy nginx server that routes request to its 127.0.0.1:5000. As we know, images are OS of their own, and the nginx would resolves localhost to itself, we don&rsquo;t want it to route to itself since our nodejs app would live in the nodejs container. We will later provide a solution to this.</p><h2 id=mongodb-and-redis-dockerfiles>MongoDB and Redis Dockerfiles<a hidden class=anchor aria-hidden=true href=#mongodb-and-redis-dockerfiles>#</a></h2><p>We won&rsquo;t be building an image for MongoDB and Redis, the major reason is that we don&rsquo;t have any customization to add to the image that we would be inheriting from. So, it is more of over-engineering to have a dockerfile that contains:</p><pre tabindex=0><code>FROM mongodb:alpine
</code></pre><p>When we can have a docker-compose file to take away that for us or create a container on the image which would be pulled from dockerhub.</p><h2 id=docker-compose>Docker-Compose<a hidden class=anchor aria-hidden=true href=#docker-compose>#</a></h2><p>Composability is one of the many features that Distinguishes Docker from a VM. From <code>Compose</code> we should understand that <em>we can create many images, containers, networks, drives on the fly in just one file.</em> This helps with maintainance and helps to conceptualize software as a mixture of dependencies in their uniqueness.</p><blockquote><blockquote><p>So, let&rsquo;s compose an architecture for NodeJS, Nginx, Mongo and Redis!</p></blockquote></blockquote><p>In the same directory, create a file named <code>docker-compose.yml</code>, compose files are <a href=https://en.wikipedia.org/wiki/YAML>YAML files</a> with commands that the docker-compose command understands.</p><p>Once that file is created, let&rsquo;s define some images that we would be needing for our architecture. First, I will define the nodejs image, making the first version of <code>docker-compose.yml</code> file to look like this:</p><pre tabindex=0><code>version: &#34;2&#34;
services:
  node:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - ./:/home/node/app
    command: &#34;npm start&#34;
    ports:
      - 5000:5000
</code></pre><p>In the snippet above, we are trying to create a node image through this compose file from <a href=#base-dockerfile>the Dockerfile we defined above</a>, (<em>the context is the path to look for, while the dockerfile is a customized name for our Dockerfile, we can omit it since our nodejs Dockerfile has the default naming convention, but, we have added it for clarity sake</em>).</p><p>Also, we could notice we were setting some information, if you can remember when how we create containers: <code>docker container run --name nginx -p 80:80 nginx</code>, we can pass parameters and further extend the image through these commands.</p><p>Here we can see that we have forwared port 5000 from the container to the container&rsquo;s 5000, map the current directory to the <code>/home/node/app</code> folder in the container and how we could specify the command we want to run after the container might have been started? That is the power of compose files. To know more about the commands that can be passed, see the <a href=https://docs.docker.com/compose/compose-file/compose-file-v2/>docker-compose documentation</a></p><p>Now testing our compose file, we can start the compose file in docker and not forget, as docker to build us the nodejs image since we have specified the build command:</p><pre tabindex=0><code>docker-compose up --build
</code></pre><p>That is it, we have our first docker-compose running!</p><p>Next, we should include our nginx config into the docer-compose file. Which would make our docker-compose.yml to look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>node</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>context</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dockerfile</span><span class=p>:</span><span class=w> </span><span class=l>node.Dockerfile</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./:/home/node/app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;npm start&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>5000</span><span class=p>:</span><span class=m>5000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w> </span><span class=c># notice this addition to the node servic</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>nginx-proxy</span><span class=w> </span><span class=c># notice this</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>default</span><span class=w> </span><span class=c># notice this</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nginx</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>context</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dockerfile</span><span class=p>:</span><span class=w> </span><span class=l>nginx.Dockerfile</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./:/home/node/app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># command: &#34;npm start&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>restart</span><span class=p>:</span><span class=w> </span><span class=l>always</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>80</span><span class=p>:</span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>depends_on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nginx-proxy</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></div><p>With this update, we have included the nginx.Dockerfile to build an nginx image for us which should include the nginx.conf we have. To be noticed in the bginx service is <code>depends_on</code> , this commands ensures that the node is started and running before nginx is started. We also added the both services to the same networks so they can communicate using their service name instead of their respective virtual ips.</p><p>For ngix.conf to work, we have to update the part that redirects to <code>localhost:5000</code> to redirect to <code>http://node:5000</code>. The node hostname would be resolved to virtual ip address by Docker during runtime. This change should make our <code>nginx.conf</code> to look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nginx data-lang=nginx><span class=line><span class=cl><span class=k>server</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kn>listen</span> <span class=mi>80</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_pass</span>         <span class=s>http://node:5000</span><span class=p>;</span> <span class=c1># updated from localhost to the service name
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kn>proxy_redirect</span>     <span class=no>off</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>Host</span> <span class=nv>$host</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>X-Real-IP</span> <span class=nv>$remote_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>X-Forwarded-For</span> <span class=nv>$proxy_add_x_forwarded_for</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=kn>proxy_set_header</span>   <span class=s>X-Forwarded-Host</span> <span class=nv>$server_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Awesome, we can build these two services and run them at the same time as we did before using: <code>docker-compose up --build</code>. Both services running? Great!</p><blockquote><blockquote><blockquote><p>If the node service is failing, do init a node project in the root directory with: <code>npm ini -y</code> and add a start script OR remove the command: npm start from the docker-compose.yml file.</p></blockquote></blockquote></blockquote><p>We are doing well!</p><p>Next let&rsquo;s include Redis service into the compose file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yml data-lang=yml><span class=line><span class=cl><span class=nt>version</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;2&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>services</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>node</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>context</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dockerfile</span><span class=p>:</span><span class=w> </span><span class=l>node.Dockerfile</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./:/home/node/app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;npm start&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>5000</span><span class=p>:</span><span class=m>5000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>depends_on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>mongodb-server</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nginx</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>build</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>context</span><span class=p>:</span><span class=w> </span><span class=l>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>dockerfile</span><span class=p>:</span><span class=w> </span><span class=l>nginx.Dockerfile</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>volumes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>./:/home/node/app</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>restart</span><span class=p>:</span><span class=w> </span><span class=l>always</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=m>80</span><span class=p>:</span><span class=m>80</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>depends_on</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>node</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c># network_mode: bridge</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>nginx-proxy</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=l>default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>redis-server</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;redis:5.0.8-alpine&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>ports</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=s2>&#34;6379:6379&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>networks</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>nginx-proxy</span><span class=p>:</span><span class=w>
</span></span></span></code></pre></div><p>It gets more interesting, but simply done. We don&rsquo;t need any special configuration or extension for the Redis Image. So, we just use the <code>image: ...</code> command instead of the build command to tell the image we want to use. This also means that docker will not build this image, rather download it from Dockerhub.</p><p>Finally, a database. Let&rsquo;s add mongodb service to complete our setup.</p><pre tabindex=0><code>version: &#34;2&#34;
services:
  node:
    build:
      context: .
      # You can rename the file to make it tell what it does.
      # since we are composing different images and not just a sigle image
      dockerfile: node.Dockerfile 
    volumes:
      - ./:/home/node/app
    command: &#34;npm start&#34;
    ports:
      - 5000:5000
    depends_on:
    # We now depends on node and mongodb server
      - redis-server
      - mongodb-server
    networks:
      - nginx-proxy
      - default
  nginx:
    build:
      context: .
      dockerfile: nginx.Dockerfile
    volumes:
      - ./:/home/node/app
    restart: always
    ports:
      - 80:80
    depends_on:
      - node
    networks:
      - nginx-proxy
      - default
  redis-server:
    image: &#34;redis:5.0.8-alpine&#34;
    ports:
      - &#34;6379:6379&#34;

  mongodb-server:
    image: &#34;mongo:4.2.3-bionic&#34;
    ports:
      - &#34;27017:27017&#34;

networks:
  nginx-proxy:
</code></pre><p>As simple as the redis service is, same with the mongodb service. We are downloading the image from github and running a mongodb-server container off it.</p><p>Great work!</p><p>Now, we can test our setup as we always do: <code>docker-compose up --build</code>.</p><h2 id=speaking-between-containers>Speaking between containers.<a hidden class=anchor aria-hidden=true href=#speaking-between-containers>#</a></h2><p>If we try to connect to the redis service from our node app we might get an error as the address 127.0.0.1 would mean the instance itself and not the host computer, same will happen with the mongodb service.</p><p>To solve this, we will add a service_name to every service we want to reference inside of another container, and ensure that the depends_on is updated to that new service name.</p><p>So our final config would look like this:</p><pre tabindex=0><code>
version: &#34;2&#34;
services:
  node:
    server_name: node
    build:
      context: .
      # You can rename the file to make it tell what it does.
      # since we are composing different images and not just a sigle image
      dockerfile: node.Dockerfile 
    volumes:
      - ./:/home/node/app
    command: &#34;npm start&#34;
    ports:
      - 5000:5000
    depends_on:
    # We now depends on node and mongodb server
      - redis-server
      - mongodb-server
    networks:
      - nginx-proxy
      - default
  nginx:
    service_name: nginx
    build:
      context: .
      dockerfile: nginx.Dockerfile
    volumes:
      - ./:/home/node/app
    restart: always
    ports:
      - 80:80
    depends_on:
      - node
    networks:
      - nginx-proxy
      - default
  redis-server:
    service_name: redis
    image: &#34;redis:5.0.8-alpine&#34;
    ports:
      - &#34;6379:6379&#34;

  mongodb-server:
    service_name: mongodb
    image: &#34;mongo:4.2.3-bionic&#34;
    ports:
      - &#34;27017:27017&#34;

networks:
  nginx-proxy:
</code></pre><p>Easy enough? Now in our source codes we can use http://redis:6379 to connect to redis service container and http://mongodb:27017 to connect to the mongodb service container.</p><p>Voila!</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Finally, we cracked it. Walking through the journey from an empty file to a docker-compose.yml file that we can share with anyone that would love to replicate same setup for their development. This was so much fun to walk through.</p><p>There is more to Docker than we have covered, don&rsquo;t hesitate to read the <a href=https://docs.docker.com/>docs</a> for more information and commads that could be used in Dockerfile and docker-compose.yml files.</p><p><strong>PLEASE!!!</strong></p><blockquote><blockquote><p><strong>Dockerize yourself at this time, stay safe, stay home, stay in a containerized environment!!!</strong></p></blockquote></blockquote><p><em>Ou re voir!</em></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://limistah.dev/tags/js/>JS</a></li></ul><nav class=paginav><a class=prev href=https://limistah.dev/posts/shiny-cutting-edge/><span class=title>Â« Prev</span><br><span>Title of the post</span>
</a><a class=next href=https://limistah.dev/posts/socketio-app-structure/><span class=title>Next Â»</span><br><span>SocketIO - App structure and architecture</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on x" href="https://x.com/intent/tweet/?text=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup&amp;url=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f&amp;hashtags=JS"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f&amp;title=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup&amp;summary=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup&amp;source=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on reddit" href="https://reddit.com/submit?url=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f&title=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on whatsapp" href="https://api.whatsapp.com/send?text=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup%20-%20https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on telegram" href="https://telegram.me/share/url?text=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup&amp;url=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dockerized Node/Nginx, MongoDB, Redis app setup on ycombinator" href="https://news.ycombinator.com/submitlink?t=Dockerized%20Node%2fNginx%2c%20MongoDB%2c%20Redis%20app%20setup&u=https%3a%2f%2flimistah.dev%2fposts%2fdocker-node-nginx-redis-mongodb%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://limistah.dev>limistah</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>